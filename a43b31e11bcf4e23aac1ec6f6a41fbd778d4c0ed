{
  "comments": [
    {
      "key": {
        "uuid": "9ab29df4_5826c7bb",
        "filename": "xlators/cluster/dht2/src/dht2-layout.h",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1004060
      },
      "writtenOn": "2015-10-21T16:09:20Z",
      "side": 1,
      "message": "I do not have outright issue with this abstraction but some points to note,\n- I am not sure this is the interface to layouts that we need, as I do not have enough data to justify the same\n- The function pointer approach works when we have different layout handlers, so that part is useful as we shift other parts of the code around independent of the layout parts\n- I possibly see us having these interfaces ATM,\n  - fetching/get/init a layout\n    - Instead of prepare, we will ideally get a layout for the volume from somewhere and populate our layout appropriately.\n    - The question is do we *use* the conf to determine everything internal to this interface or not, or in args to this interface\n  - return/destroy/fini the fetched layout\n  - Search a layout given a key, to return a xlator\n    - in args to this function is also interesting, we use bucket ID or a number, in the future some other form could use a different in arg to help decide the same, hence a void * with the layout helps, as we can typecast it based on the layout type, which should be a part of the layout anyway.\n  - We will *not* update the layout, as that would be a separate fetch cycle, and we need to operate on *a* layout that we think is appropriate. (ideally this is something that happens with a graph switch?)\n\nso maybe we can look at the abstraction as,\n- dht2_layout_handler {\n    .d2layhandler_init (prepare)\n    .d2layhandler_fini (wreck)\n    .d2layhandler_search\n}",
      "revId": "a43b31e11bcf4e23aac1ec6f6a41fbd778d4c0ed",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ab29df4_1ef2779a",
        "filename": "xlators/cluster/dht2/src/dht2-layout.h",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1005325
      },
      "writtenOn": "2015-10-22T08:12:46Z",
      "side": 1,
      "message": "Shyam,\n\nYou\u0027re correct when you say that normally a layout is fetched from somewhere (MDS/DS export). Therefore, -\u003elayoutprepare() would be used to setup some prefetch information, e.g., in fixed bucket layout implementation this is used to initialize (lstart, lrange). This is basically implementation dependent and IMO a form of programming paradigm to some extent thereby moving the actual layout generation (or fetching) to -\u003elayoutgen.\n\nThe flow in this case makes things much more clear:\n\n-\u003elayoutprepare()\n-\u003elayoutgen()\n-\u003elayoutwreck()\n\n......\n......\n......\n\nand later when you want to find the appropriate subvolume use -\u003elayoutsearch().\n\n-\u003elayoutwreck() just deallocated whatever was allocated in -\u003elayoutpreare(). The actual layout stored elsewhere (inode context, subvolume list, etc..) would be deallocated when that particular instance is about to go away. Also, layout handlers are free to have some of the above functions as no-op. Therefore, the above abstraction.",
      "parentUuid": "9ab29df4_5826c7bb",
      "revId": "a43b31e11bcf4e23aac1ec6f6a41fbd778d4c0ed",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}