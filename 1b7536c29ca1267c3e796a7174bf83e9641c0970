{
  "comments": [
    {
      "key": {
        "uuid": "9ad9bd40_b04e0f95",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1005325
      },
      "writtenOn": "2015-08-24T06:33:09Z",
      "side": 1,
      "message": "Where does this FD point to? My first guess would be DS. But to implement calls like fstat() where the information needs to be fetched from the MDS (post phase I).\n\nFurthermore, it would be good to churn out open() call and the relevant structures that are maintained in DS/MDS.\n\n[\n    There is some mention about open{dir} in the initial DHT2    \n    prototype design, I\u0027ll probably read that again.\n]",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_ae995021",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1004060
      },
      "writtenOn": "2015-08-24T14:20:15Z",
      "side": 1,
      "message": "Venky, this is a good question/observation and here are my thoughts.\n\n- I think the fd should be opened at the MDS, as we need to do access checks before allowing the fd to be opened.\n  - Or, rather at the file inode location (so that the statement is true for P1 and P2 related designs)\n- Hence the open fd is just a gateway to the DS which treats this as an \u0027authoritative\u0027 source to allow data operations on the DS side\n  - P1 this is the same location, P2 it is the DS side of affairs.\n- This \u0027authority\u0027 should be provided somehow, signed blob, that the DS can verify as authoritative? Not sure yet...\n\nThis also opens up another area to think through, performance of small files,\n- There are 2 cases here, \n  - open/creat -\u003e read/write\n  - anonFD cases for [creat -\u003e] read/write\n\nIn short what is the # of RPCs that we need to achieve the case of small file creation (including data write) and how does that stack up with older DHT. I think the key is in map/extent/layout manipulation which could cause additional RPC traffic than the current case. Also, I think this is a P2 problem.",
      "parentUuid": "9ad9bd40_b04e0f95",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_a9e14ad2",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1005325
      },
      "writtenOn": "2015-08-24T15:45:53Z",
      "side": 1,
      "message": "If the fd is open()\u0027d _only_ in the MDS, that would break a client reading an object (open fd) in the mid of the object getting unlink()\u0027d. I guess, there needs to be an active fd reference in the DS too. One could still implement similar semantics by using some form of reference counting, but that looks like an added load.",
      "parentUuid": "9ad9bd40_ae995021",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_2950da5d",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1005325
      },
      "writtenOn": "2015-08-24T16:30:35Z",
      "side": 1,
      "message": "Just to be elaborate here, access checks would be done at the MDS, but the actual fd still needs to be open()\u0027d on the DS. There also needs to be an fd on the MDS for metadata updations (size, {a,c,m}time, etc..) so that the metadata can still be updated when permission are changed _after_ an fd was open()\u0027d on the object.\n\nThoughts, anyone?",
      "parentUuid": "9ad9bd40_a9e14ad2",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_89ed6691",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 126,
      "author": {
        "id": 1004060
      },
      "writtenOn": "2015-08-24T17:13:29Z",
      "side": 1,
      "message": "My thought:\n\nIf inode and data are separate (i.e P2), then we just need the fd open against the MDS or inode. unlink would remove the name from the directory inode without any checks. The inode itself would be \u0027unlinked\u0027 only when active ref to it becomes 0 (i.e no open fd\u0027s).\n\nWhen the inode is unlinked that is when the data is unliked/freed as well. So in essence data unlinking (at the DS) is when inode is unlinked, and that is what protects data/DS without needing an open fd/ref against the DS to be present.\n\nWhen a file is unliked, we need to mark the inode ready for garbage collection once all refs to it are removed. This \u0027mark\u0027 should survive reboots, so that inode leaks are prevented.\n\nA mark on the inode (i.e on disk) when it is unlinked is one way to achieve this persistence information, but how would the FS realize this inode is ready for unlinking on a reboot would then be the problem. For the second part some form of journal or something like indices (if I am not wrong) would need to be used.\n\nThe mark should also serve as a data point for future opens against the inode (i.e GFID based access) to fail, as it is marked for unlink, and hence retained as a part of the in-memory inode information on the brick.\n\nFurther, inode with link counts greater than one will not get unlinked till the last name ref is removed (just stating for completeness).",
      "parentUuid": "9ad9bd40_2950da5d",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_733011e9",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1005325
      },
      "writtenOn": "2015-08-24T06:33:09Z",
      "side": 1,
      "message": "I thought this will be in the first prototype :P",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_534a2d56",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 200,
      "author": {
        "id": 1005325
      },
      "writtenOn": "2015-08-24T06:33:09Z",
      "side": 1,
      "message": "Maintain two implementations of posix: posix-ds, posix-mds. I think there would be lots of common code between them except the actual FOP each instance implements.",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad9bd40_a9030a0c",
        "filename": "xlators/cluster/dht2/docs/POSIX_FunctionalSpec.md",
        "patchSetId": 1
      },
      "lineNbr": 200,
      "author": {
        "id": 1004060
      },
      "writtenOn": "2015-08-24T14:20:15Z",
      "side": 1,
      "message": "That is one way, in which case DHT2 decides which way to route the 2 requests, in which case DHT2 can also pass this information through an xdata name-value pair. Basically, I still need to break the logjam on how the client decides and hence what information it sends down the 2 creation FOPs.\n\nI agree that separating the 2 POSIX implementation (with the large amount common code) is something that seems to make sense.\n\nAlso in P2, this creation is a single FOP, as we create the inode and name on the same subvol (unless it is a link call). Hence at that point this confusion may disappear.",
      "parentUuid": "9ad9bd40_534a2d56",
      "revId": "1b7536c29ca1267c3e796a7174bf83e9641c0970",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}